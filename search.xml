<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OkHttp解析(二)--Dispatcher 类详解]]></title>
    <url>%2F2019%2F01%2F24%2FOkHttp%E8%A7%A3%E6%9E%90%2FOkHttp%E8%A7%A3%E6%9E%90(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Dispatcher 类详解Dispatcher负责请求的分发 1、线程池executeService 123456789/** Executes calls. Created lazily. */private ExecutorService executorService;public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false)); &#125; return executorService; &#125; Dispatcher内部实现了懒加载的无边界限制的线程池;参数解析 1、0：核心线程数量，保持在线程池中的线程数量(即使已经空闲)，为0代表线程空闲后不会保留，等待一段时间后停止。 2、Integer.MAX_VALUE:表示线程池可以容纳最大线程数量 3、TimeUnit.SECOND:当线程池中的线程数量大于核心线程时，空闲的线程就会等待60s才会被终止，如果小于，则会立刻停止。 4、new SynchronousQueue()：线程等待队列。同步队列，按序排队，先来先服务 5、Util.threadFactory(“OkHttp Dispatcher”, false):线程工厂，直接创建一个名为OkHttp Dispatcher的非守护线程。 (1)SynchronousQueue每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。因此队列内部其实没有任何一个元素，或者说容量为0，严格说并不是一种容器，由于队列没有容量，因此不能调用peek等操作，因此只有移除元素才有元素，显然这是一种快速传递元素的方式，也就是说在这种情况下元素总是以最快的方式从插入者(生产者)传递给移除者(消费者),这在多任务队列中最快的处理任务方式。对于高频请求场景，无疑是最合适的。 (2)在OKHttp中，创建了一个阀值是Integer.MAX_VALUE的线程池，它不保留任何最小线程，随时创建更多的线程数，而且如果线程空闲后，只能多活60秒。所以也就说如果收到20个并发请求，线程池会创建20个线程，当完成后的60秒后会自动关闭所有20个线程。他这样设计成不设上限的线程，以保证I/O任务中高阻塞低占用的过程，不会长时间卡在阻塞上。 2、发起请求 整个框架主要通过Call来封装每一次的请求。同时Call持有OkHttpClient和一份Request。而每一次的同步或者异步请求都会有Dispatcher的参与。 (1)、同步 第一步是：是调用了RealCall的execute()方法里面调用executed(this);12345678910111213// RealCall方法@Override public Response execute() throws IOException &#123; // 代码省略 try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); // 代码省略 &#125; catch (IOException e) &#123; // 代码省略 &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; 第二步：在Dispatcher里面的executed执行入队操作 12345// Dispatcher方法 /** Used by &#123;@code Call#execute&#125; to signal it is in-flight. */ synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call); &#125; 第三步：执行getResponseWithInterceptorChain();进入拦截器链流程，然后进行请求，获取Response，并返回Response result 。 第四步：执行client.dispatcher().finished(this)操作 1234/** Used by &#123;@code Call#execute&#125; to signal completion. */ void finished(RealCall call) &#123; finished(runningSyncCalls, call); &#125; 这里其实做的是出队操作。至此同步的调度就已经结束了 (2)、异步 第一步 是调用了RealCall的enqueue()方法 12345678910// RealCall方法 @Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback)); &#125; 第二步：在Dispatcher里面的enqueue执行入队操作12345678910111213141516171819202122232425262728293031323334// Dispatcher方法 void enqueue(AsyncCall call) &#123; synchronized (this) &#123; readyAsyncCalls.add(call); &#125; promoteAndExecute(); &#125; private boolean promoteAndExecute() &#123; assert (!Thread.holdsLock(this)); List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) &#123; for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall asyncCall = i.next(); if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity. if (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) continue; // Host max capacity. i.remove(); executableCalls.add(asyncCall); runningAsyncCalls.add(asyncCall); &#125; isRunning = runningCallsCount() &gt; 0; &#125; for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; AsyncCall asyncCall = executableCalls.get(i); asyncCall.executeOn(executorService()); &#125; return isRunning; &#125; runningAsyncCalls.size() &lt; maxRequests 表示当前正在运行的AsyncCall是否小于maxRequests = 64runningCallsForHost(call) &lt; maxRequestsPerHos 表示同一个地址访问的AsyncCall是否小于maxRequestsPerHost = 5;即 当前正在并发的请求不能超过64且同一个地址的访问不能超过5个 将Call加入readyAsyncCalls等待队列：如果当前正在执行的call的数量大于maxRequest(64),或者该call的Host上的call超过maxRequestsPerHos(5),则继续等待，否则①加入runningAsyncCalls ②通过迭代器,从readyAsyncCalls删除③执行AsyncCall的executeOn方法. AsyncCall的executeOn最终会执行execute()方法。12345678910111213141516171819202122@Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;)); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; 第三步：执行getResponseWithInterceptorChain();进入拦截器链流程，然后进行请求，获取Response。 第四步：如果是正常的获取到Response，则执行responseCallback.onResponse() 第五步：执行client.dispatcher().finished(this)操作 进行出队操作 1234/** Used by &#123;@code AsyncCall#run&#125; to signal completion. */ void finished(AsyncCall call) &#123; finished(runningAsyncCalls, call); &#125; Dispatcher的finished方法 12345678910111213private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call) &#123; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!"); idleCallback = this.idleCallback; &#125; boolean isRunning = promoteAndExecute(); if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125; &#125; 如果无法将任务从队列中移除，则会抛出异常.之后会 调用promoteAndExecute() 方法.对readyAsyncCalls和runningAsyncCalls操作,执行下一个任务。 总结： 1、异步流程总结所以简单的描述下异步调度为：直接加入readyAsyncCalls队列，会调用promoteAndExecute()，来把readyAsyncCalls队列中的Async移出来并加入到runningAsyncCalls，并开始执行。然后在当前线程中去执行Call的getResponseWithInterceptorChain（）方法，直接获取当前的返回数据Response 2、对比同步和异步任务，我们会发现:同步请求和异步请求原理都是一样的，都是在getResponseWithInterceptorChain()函数通过Interceptor链条来实现网络请求逻辑，而异步任务则通过ExecutorService来实现的。PS:在Dispatcher中添加一个封装了Callback的Call的匿名内部类AsyncCall来执行当前的Call。这个AsyncCall是Call的匿名内部类。AsyncCall的execute方法仍然会回调到Call的getResponseWithInterceptorChain方法来完成请求,同时将返回数据或者状态通过Callback来完成。]]></content>
      <categories>
        <category>OkHttp解析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OkHttp解析(一)--整体流程分析]]></title>
    <url>%2F2019%2F01%2F24%2FOkHttp%E8%A7%A3%E6%9E%90%2FOkHttp%E8%A7%A3%E6%9E%90(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[OkHttp解析(一)一、OKHTTP使用：1、GET请求12345678OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(url) .build(); Response response = client.newCall(request).execute(); return response.body().string(); 2、POST请求123456789101112131415public static final MediaType JSON = MediaType.parse("application/json; charset=utf-8"); OkHttpClient client = new OkHttpClient(); RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute(); return response.body().string(); 三、OKHTTP源码流程分析(一)、OKHTTP 同步请求debug代码跟踪12345678OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(url) .build(); Response response = client.newCall(request).execute(); return response.body().string(); 在上面代码中,先是创建了一个OKHttpClient对象 1、OKHttpClient类详解 OKHttpClient类就比较简单了： 1、里面包含了很多对象，其实OKhttp的很多功能模块都包装进这个类，让这个类单独提供对外的API，这种外观模式的设计十分的优雅。==外观模式==。 2、而内部模块比较多，就使用了Builder模式(建造器模式)。==Builder模式(建造器模式)== 3、它的方法只有一个：newCall.返回一个Call对象(一个准备好了的可以执行和取消的请求)。 在创建了OKHttpClient后又new了一个Rquest对象。说道Request又不得不提Response。 2、Request、Response类详解 1、Request、Response分别抽象成请求和相应 2、其中Request包括Headers和RequestBody，而RequestBody是abstract的，他的子类是有FormBody (表单提交的)和 MultipartBody(文件上传)，分别对应了两种不同的MIME类型FormBody ：”application/x-www-form-urlencoded”MultipartBody：”multipart/“+xxx. 3、其中Response包括Headers和ResponseBody，而ResponseBody是abstract的，所以他的子类也是有两个:RealResponseBody和CacheResponseBody,分别代表真实响应和缓存响应。 4、由于RFC协议规定，所以所有的头部信息不是随便写的，request的header与response的header的标准都不同。具体的见 List of HTTP header fields。OKHttp的封装类Request和Response为了应用程序编程方便，会把一些常用的Header信息专门提取出来，作为局部变量。比如contentType，contentLength，code,message,cacheControl,tag…它们其实都是以name-value对的形势，存储在网络请求的头部信息中。 根据从上面的GET请求，显示用builder构建了Request对象，然后执行了OKHttpClient.java的newCall方法，那么咱们就看看这个newCall里面都做什么操作？ 123456/** * Prepares the &#123;@code request&#125; to be executed at some point in the future. */ @Override public Call newCall(Request request) &#123; return new RealCall(this, request, false /* for web socket */); &#125; Call是个什么东西，那咱们看下Call这个类 3、Call类详解 Call: HTTP请求任务封装. 可以说我们能用到的操纵基本上都定义在这个接口里面了，所以也可以说这个类是OKHttp类的核心类了。我们可以通过Call对象来操作请求了。而Call接口内部提供了Factory工厂方法模式(将对象的创建延迟到工厂类的子类去进行，从而实现动态配置) 12345678910111213141516171819202122public interface Call extends Cloneable &#123; // 原始的Request请求对象 Request request(); // 同步请求方法 Response execute() throws IOException; // 异步请求方法 void enqueue(Callback responseCallback); // 取消请求 void cancel(); boolean isExecuted(); boolean isCanceled(); Timeout timeout(); Call clone(); interface Factory &#123; Call newCall(Request request); &#125;&#125; 在源码中，OKHttpClient实现了Call.Factory接口，返回了一个RealCall对象。那我们就来看下RealCall这个类 4、RealCall类详解 123456/** * Prepares the &#123;@code request&#125; to be executed at some point in the future. */ @Override public Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */); &#125; 1、OkHttpClient的newCall方法里面new了RealCall的对象，但是RealCall的构造函数需要传入一个OKHttpClient对象和Request对象(PS：第三个参数false表示不是webSokcet).因此RealCall包装了Request对象。所以RealCall可以很方便地使用这两个对象。 2、RealCall里面的两个关键方法是：execute 和 enqueue。分别用于同步和异步得执行网络请求。 3、RealCall还有一个重要方法是:getResponseWithInterceptorChain，添加拦截器，通过拦截器可以将一个流式工作分解为可配置的分段流程，既增加了灵活性也实现了解耦，关键还可以自有配置，非常完美。 所以client.newCall(request).execute();实际上执行的是RealCall的execute方法，现在咱们再回来看下RealCall的execute的具体实现 123456789101112131415161718192021@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); timeout.enter(); eventListener.callStart(this); try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException("Canceled"); return result; &#125; catch (IOException e) &#123; e = timeoutExit(e); eventListener.callFailed(this, e); throw e; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; 首先是 1234synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; 判断call是否执行过，可以看出每个Call对象只能使用一次原则。然后调用了captureCallStackTrace()方法。 12345678910 private void captureCallStackTrace() &#123; Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()"); retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace); &#125; public final class RetryAndFollowUpInterceptor implements Interceptor &#123; public void setCallStackTrace(Object callStackTrace) &#123; this.callStackTrace = callStackTrace; &#125;&#125; 综上所示captureCallStackTrace()这个方法其实是捕获了这个请求的StackTrace。 然后进入了第一个核心类—Dispatcher: 123456789101112try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException("Canceled"); return result;&#125; catch (IOException e) &#123; e = timeoutExit(e); eventListener.callFailed(this, e); throw e;&#125; finally &#123; client.dispatcher().finished(this);&#125; OKHttpClient的dispatcher()方法的具体内容如下图1234//OKHttpClient.java public Dispatcher dispatcher() &#123; return dispatcher; &#125; client.dispatcher()返回的是Dispatcher对象，那么这个Dispatcher对象是何时创建的那？在OkHttpClient.java里面Build类里面的构造函数里面. 123456789//OkHttpClient.javapublic static final class Builder &#123; //其它代码先忽略掉 Dispatcher dispatcher; public Builder() &#123; dispatcher = new Dispatcher(); //其它代码先忽略掉 &#125;&#125; 所以当我通过Builder模式创建OKHttpClient的时候就创建了一个Dispatcher对象,那么咱们看下dispatcher里面的execute()是如何处理的: 12345678910111213/** Used by &#123;@code Call#execute&#125; to signal it is in-flight. */ synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call); &#125; /** Ready async calls in the order they'll be run. */ private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running synchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); Dispatcher里面定义了三个双向队列，看下注释，我们大概能明白==readyAsyncCalls== 是一个存放了==等待执行任务Call的双向队==列，==runningAsyncCalls==是一个存放==异步请求任务Call的双向任务队列==，==runningSyncCalls==是一个存放==同步请求的双向队列==。 执行完client.dispatcher().executed(this),将Call对象添加至runningSyncCalls后，要走到getResponseWithInterceptorChain(); getResponseWithInterceptorChain() 12345678910111213141516171819202122232425262728293031323334 Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); //添加开发者应用层自定义的Interceptor interceptors.addAll(client.interceptors()); //这个Interceptor是处理请求失败的重试，重定向 interceptors.add(retryAndFollowUpInterceptor); //这个Interceptor工作是添加一些请求的头部或其他信息 //并对返回的Response做一些友好的处理（有一些信息你可能并不需要） interceptors.add(new BridgeInterceptor(client.cookieJar())); //这个Interceptor的职责是判断缓存是否存在，读取缓存，更新缓存等等 interceptors.add(new CacheInterceptor(client.internalCache())); //这个Interceptor的职责是建立客户端和服务器的连接 interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; //添加开发者自定义的网络层拦截器 interceptors.addAll(client.networkInterceptors()); &#125; // 真正执行网络请求的拦截器 interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest); &#125;&#125; 发现new了一个ArrayList，然后就是不断的add，后面 new了 RealInterceptorChain对象，最后调用了chain.proceed()方法。先看下RealInterceptorChain的构造函数。 123456789101112131415public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call, EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) &#123; this.interceptors = interceptors; this.connection = connection; this.streamAllocation = streamAllocation; this.httpCodec = httpCodec; this.index = index; this.request = request; this.call = call; this.eventListener = eventListener; this.connectTimeout = connectTimeout; this.readTimeout = readTimeout; this.writeTimeout = writeTimeout;&#125; 发现什么都没做就是做了赋值操作.后面跟踪下chain.proceed()方法由于Interceptor是个接口，所以应该是具体实现类RealInterceptorChain的proceed实现。 1234567891011public interface Interceptor &#123; Response intercept(Chain chain) throws IOException; interface Chain &#123; Request request(); Response proceed(Request request) throws IOException; Connection connection(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public final class RealInterceptorChain implements Interceptor.Chain&#123; Response intercept(Chain chain) throws IOException; @Override public Response proceed(Request request) throws IOException &#123; return proceed(request, streamAllocation, httpCodec, connection); &#125; public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; // If we already have a stream, confirm that the incoming request will use it. if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123; throw new IllegalStateException("network interceptor " + interceptors.get(index - 1) + " must retain the same host and port"); &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123; throw new IllegalStateException("network interceptor " + interceptors.get(index - 1) + " must call proceed() exactly once"); &#125; // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123; throw new IllegalStateException("network interceptor " + interceptor + " must call proceed() exactly once"); &#125; // Confirm that the intercepted response isn't null. if (response == null) &#123; throw new NullPointerException("interceptor " + interceptor + " returned null"); &#125; if (response.body() == null) &#123; throw new IllegalStateException( "interceptor " + interceptor + " returned a response with no body"); &#125; return response; &#125;&#125; 由于在构造RealInterceptorChain对象时候httpCodec直接赋予了null，所以下面代码直接略过1234567891011// If we already have a stream, confirm that the incoming request will use it. if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123; throw new IllegalStateException("network interceptor " + interceptors.get(index - 1) + " must retain the same host and port"); &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123; throw new IllegalStateException("network interceptor " + interceptors.get(index - 1) + " must call proceed() exactly once"); &#125; 然后看到在proceed方面里面又==new了一个RealInterceptorChain类的next对象==，温馨提示下，里面的==streamAllocation,httpCodec,connection都是null==，所以这个==next对象和chain最大的区别就是index属性值不同chain是0.而next是1==，然后取interceptors下标为1的对象的interceptor。由从上文可知，如果没有开发者自定义的Interceptor时，首先调用的RetryAndFollowUpInterceptor，如果有开发者自己定义的interceptor则调用开发者interceptor。 在proceed方法中的核心代码可以看到，proceed实际上也做了两件事： 创建下一个拦截链。传入index+1使得下一个拦截器链只能从下一个拦截器开始访问 执行索引为index的intercept方法，并将下一个拦截器链传入该方法 第一个拦截器RetryAndFollowUpInterceptor的intercept方法 123//忽略部分代码 response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null); //忽略部分代码 这行代码就是执行下一个拦截器链的proceed方法。而我们知道在下一个拦截器链中又会执行下一个拦截器的intercept方法。所以整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作. 这也是OkHttp拦截器的链式执行逻辑。而一个拦截器的intercept方法所执行的逻辑大致分为三部分： 在发起请求前对request进行处理 调用下一个拦截器，获取response 对response进行处理，返回给上一个拦截器 (二)、OKHTTP 异步请求debug代码跟踪1234567891011121314OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(url) .build(); Response response = client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125; &#125;); 前面和同步一样new了一个OKHttp和Request,异步执行的是enqueue()方法, 123456789@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback)); &#125; 和同步一样先调用了captureCallStackTrace();然后调用 client.dispatcher().enqueue(new AsyncCall(responseCallback));client.dispatcher()返回的是Dispatcher对象所以实际调用的是Dispatcher的enqueue()。 123456void enqueue(AsyncCall call) &#123; synchronized (this) &#123; readyAsyncCalls.add(call); &#125; promoteAndExecute(); &#125; 执行enqueue()方法的时候传入一个AsyncCall对象,将该对象添加至readyAsyncCalls队列中。 12345678910111213141516171819202122/** * Runnable implementation which always sets its thread name. */public abstract class NamedRunnable implements Runnable &#123; protected final String name; public NamedRunnable(String format, Object... args) &#123; this.name = Util.format(format, args); &#125; @Override public final void run() &#123; String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try &#123; execute(); &#125; finally &#123; Thread.currentThread().setName(oldName); &#125; &#125; protected abstract void execute();&#125; NamedRunnable的作用就是设置了线程的name，然后回调子类的execute方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768final class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; AsyncCall(Callback responseCallback) &#123; super("OkHttp %s", redactedUrl()); this.responseCallback = responseCallback; &#125; String host() &#123; return originalRequest.url().host(); &#125; Request request() &#123; return originalRequest; &#125; RealCall get() &#123; return RealCall.this; &#125; /** * Attempt to enqueue this async call on &#123;@code executorService&#125;. This will attempt to clean up * if the executor has been shut down by reporting the call as failed. */ void executeOn(ExecutorService executorService) &#123; assert (!Thread.holdsLock(client.dispatcher())); boolean success = false; try &#123; executorService.execute(this); success = true; &#125; catch (RejectedExecutionException e) &#123; InterruptedIOException ioException = new InterruptedIOException("executor rejected"); ioException.initCause(e); eventListener.callFailed(RealCall.this, ioException); responseCallback.onFailure(RealCall.this, ioException); &#125; finally &#123; if (!success) &#123; client.dispatcher().finished(this); // This call is no longer running! &#125; &#125; &#125; @Override protected void execute() &#123; boolean signalledCallback = false; timeout.enter(); try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; e = timeoutExit(e); if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; &#125; 执行enqueue()方法会promoteAndExecute()方法. 1234567891011121314151617181920212223242526272829private int maxRequests = 64;private int maxRequestsPerHost = 5;private boolean promoteAndExecute() &#123; assert (!Thread.holdsLock(this)); List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) &#123; for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall asyncCall = i.next(); if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity. if (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) continue; // Host max capacity. i.remove(); executableCalls.add(asyncCall); runningAsyncCalls.add(asyncCall); &#125; isRunning = runningCallsCount() &gt; 0; &#125; for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; AsyncCall asyncCall = executableCalls.get(i); asyncCall.executeOn(executorService()); &#125; return isRunning;&#125; 创建executableCalls集合,用于存储能执行的AsyncCall对象，遍历readyAsyncCalls异步队列，如果正在执行的异步请求小于64，并且请求同一个主机小于5的时候就先往正在运行的队列里面添加这个call,并将其从readyAsyncCalls移除,添加到executableCalls中.遍历完readyAsyncCalls后,循环遍历executableCalls,执行AsyncCall的executeOn方法。 1234for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; AsyncCall asyncCall = executableCalls.get(i); asyncCall.executeOn(executorService()); &#125; 1234567public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false)); &#125; return executorService; &#125; executorService()方法创建了一个最大线程数为 Integer.MAX_VALUE的线程池。 在AsyncCall的 executeOn方法中执行了executorService.execute(this);最终会执行AsyncCall的execute()方法。 12345678910111213141516171819202122232425@Override protected void execute() &#123; boolean signalledCallback = false; timeout.enter(); try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; e = timeoutExit(e); if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; 又回到了之前同步的getResponseWithInterceptorChain()里面，根据返回的response来回调callback。 同步执行的是RealCall的execute()方法,将RealCall对象添加至同步队列中. 12client.dispatcher().executed(this);Response result = getResponseWithInterceptorChain(); 异步执行的是AsyncCall的execute()方法,根据具体判断，将AsyncCall对象添加至等待队列或者执行队列。详见:promoteAndExecute()方法 两者最终都会执行getResponseWithInterceptorChain()方法， 1Response response = getResponseWithInterceptorChain(); 最终都会在try,catch的finally方法中执行 client.dispatcher().finished(this),将任务从队列中移除。 12345678try &#123; Response response = getResponseWithInterceptorChain(); // 代码省略...&#125; catch (IOException e) &#123; // 代码省略...&#125; finally &#123; client.dispatcher().finished(this);&#125; 同步执行的是finished(RealCall call),异步执行的是finished(AsyncCall call)。 12345678void finished(AsyncCall call) &#123; finished(runningAsyncCalls, call); &#125; /** Used by &#123;@code Call#execute&#125; to signal completion. */ void finished(RealCall call) &#123; finished(runningSyncCalls, call); &#125; 整个网络访问的核心步骤]]></content>
      <categories>
        <category>OkHttp解析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础--注解]]></title>
    <url>%2F2019%2F01%2F23%2FJava%E5%9F%BA%E7%A1%80--%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解(Annotation)相当于一种标记，在程序中加入注解就等于为程序打上某种标签，没有加，则等于没有任何标签，以后，javac编译器、开发工具和其他程序可以通过反射来了解你的类及各种元素上有无何种标签，看你的程序有什么标签，就去干相应的事，标签可以加在包、类，属性、方法，方法的参数以及局部变量上。 注解语法其实同 classs 和 interface 一样，注解也属于一种类型。它是在 Java SE 5.0 版本中开始引入的概念。 注解的定义注解通过 @interface关键字进行定义。 12public @interface TestAnnotation &#123;&#125; 它的形式跟接口很类似，不过前面多了一个 @ 符号。上面的代码就创建了一个名字为 TestAnnotaion 的注解。 你可以简单理解为创建了一张名字为 TestAnnotation 的标签。 注解的应用123@TestAnnotationpublic class Test &#123;&#125; 创建一个类 Test,然后在类定义的地方加上 @TestAnnotation 就可以用 TestAnnotation 注解这个类了。 你可以简单理解为将 TestAnnotation 这张标签贴到 Test 这个类上面。不过，要想注解能够正常工作，还需要介绍一下一个新的概念那就是元注解。 元注解元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。 如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。 元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。 @RetentionRetention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。 它的取值如下： RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 分别对应：Java源文件(.java文件)—-&gt;.class文件—-&gt;内存中的字节码 当在Java源程序上加了一个注解，这个Java源程序要由javac去编译，javac把java源文件编译成.class文件，在编译成class时可能会把Java源程序上的一些注解给去掉，java编译器(javac)在处理java源程序时，可能会认为这个注解没有用了，于是就把这个注解去掉了，那么此时在编译好的class中就找不到注解了， 这是编译器编译java源程序时对注解进行处理的第一种可能情况，假设java编译器在把java源程序编译成class时，没有把java源程序中的注解去掉，那么此时在编译好的class中就可以找到注解，当程序使用编译好的class文件时，需要用类加载器把class文件加载到内存中，class文件中的东西不是字节码，class文件里面的东西由类加载器加载到内存中去，类加载器在加载class文件时，会对class文件里面的东西进行处理，如安全检查，处理完以后得到的最终在内存中的二进制的东西才是字节码，类加载器在把class文件加载到内存中时也有转换，转换时是否把class文件中的注解保留下来，这也有说法，所以说==一个注解的生命周期有三个阶段：java源文件是一个阶段，class文件是一个阶段，内存中的字节码是一个阶段,javac把java源文件编译成.class文件时，有可能去掉里面的注解，类加载器把.class文件加载到内存时也有可能去掉里面的注解，因此在自定义注解时就可以使用Retention注解指明自定义注解的生命周期，自定义注解的生命周期是在RetentionPolicy.SOURCE阶段(java源文件阶段)，还是在RetentionPolicy.CLASS阶段(class文件阶段)，或者是在RetentionPolicy.RUNTIME阶段(内存中的字节码运行时阶段)，根据JDK提供的API可以知道默认是在RetentionPolicy.CLASS阶段 (JDK的API写到：the retention policy defaults to RetentionPolicy.CLASS)==. @Documented@Documented 注解表明，无论何时使用指定的注释，都应该使用Javadoc工具对这些元素进行文档化。 @Target@Target元注解决定了一个注解可以标识到哪些成分上，如标识在在类身上，或者属性身上，或者方法身上等成分，@Target默认值为任何元素(成分) @Target 有下面的取值： ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @Inherited当一个类继承了拥有此注解的类时，即使当前类没有任何注解。只要父类的注解拥有(@Inherited)属性，则在子类中可以获取到此注解 自定义两个注解UserAnnotation和BAnnotation,其中Class A用UserAnnotation标注,Class B用BAnnotation标注,同时继承至A, 123456789101112131415161718192021222324@Inherited@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface UserAnnotation &#123; String name() default "李四"; String sex() default "男"; String value() ;&#125;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface BAnnotation &#123; String value() default "20";&#125;@UserAnnotation("张三") class A &#123;&#125;@BAnnotation("30")public class B extends A&#123;&#125; 测试代码： 12345678if (B.class.isAnnotationPresent(UserAnnotation.class))&#123; UserAnnotation annotation = B.class.getAnnotation(UserAnnotation.class); System.out.println(annotation.value());&#125;if (B.class.isAnnotationPresent(BAnnotation.class))&#123; BAnnotation annotation = B.class.getAnnotation(BAnnotation.class); System.out.println(annotation.value());&#125; 输出： 12UserAnnotation : 张三BAnnotation : 30 说明Class B同时拥有UserAnnotation和BAnnotation注解,将UserAnnotation注解的@Inherited注释后再次运时,只有一个输出1BAnnotation : 30 注解的属性注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; int id(); String msg();&#125; 上面代码定义了 TestAnnotation 这个注解中拥有 id 和 msg 两个属性。在使用的时候，我们应该给它们进行赋值。 赋值的方式是在注解的括号内以 value=”” 形式，多个属性之前用 ，隔开。 1234@TestAnnotation(id=3,msg="hello annotation")public class Test &#123;&#125; 注解中定义属性时它的类型必须是 8 种基本数据类型外加 类、接口、注解及它们的数组。 注解中属性可以有默认值，默认值需要用 default 关键值指定。 123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; public int id() default -1; public String msg() default &quot;Hi&quot;;&#125; 如果一个注解中有一个名称为value的属性，且你只想设置value属性(即其他属性都采用默认值或者你只有一个value属性)，那么可以省略掉“value=”部分。 123456789101112@SuppressWarnings("deprecation")public @interface Check &#123; String value();&#125;@Check("hi")int a;@Check(value="hi")int a; 两者效果是一样的 Java 预置的注解Java 语言本身已经提供了几个现成的注解 @Deprecated这个元素是用来标记过时的元素，想必大家在日常开发中经常碰到。编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量。 @Override提示子类要复写父类中被 @Override 修饰的方法 @SuppressWarnings阻止警告的意思。之前说过调用被 @Deprecated 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 @SuppressWarnings 达到目的。 123456@SuppressWarnings("deprecation")public void test1()&#123; Hero hero = new Hero(); hero.say(); hero.speak();&#125; 注解的提取前面的内容是讲怎么写注解，然后贴到哪个地方去，而现在我们要做的工作就是检阅这些标签内容。 形象的比喻就是你把这些注解标签在合适的时候撕下来，然后检阅上面的内容信息. 要想正确检阅注解，离不开一个手段，那就是反射。 注解与反射。注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解 12public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123;&#125; 然后通过 getAnnotation() 方法来获取 Annotation 对象。 12public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123;&#125; 或者是 getAnnotations() 方法。 12public Annotation[] getAnnotations() &#123;&#125; 前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。 12345678if (B.class.isAnnotationPresent(UserAnnotation.class))&#123; UserAnnotation annotation = B.class.getAnnotation(UserAnnotation.class); System.out.println(annotation.value());&#125;if (B.class.isAnnotationPresent(BAnnotation.class))&#123; BAnnotation annotation = B.class.getAnnotation(BAnnotation.class); System.out.println(annotation.value());&#125; 输出： 12UserAnnotation : 张三BAnnotation : 30 面的例子中，只是检阅出了注解在类上的注解，其实属性、方法上的注解照样是可以的。同样还是要借助于反射。 这里自定义了5个注解 ClassAnnotation,FieldAnnotation,MethodAnnotation,RunTimeAnnotation,SourceAnnotation ClassAnnotation12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface ClassAnnotation &#123; String value() default "类注解";&#125; FieldAnnotation12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface FieldAnnotation &#123; String value() default "字段注解"; &#125; MethodAnnotation12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MethodAnnotation &#123; String value() default "方法注解";&#125; RunTimeAnnotation123@Retention(RetentionPolicy.RUNTIME)public @interface RunTimeAnnotation &#123;&#125; SourceAnnotation123@Retention(RetentionPolicy.SOURCE)public @interface SourceAnnotation &#123;&#125; Test类： 12345678910111213@ClassAnnotationpublic class Test &#123; @FieldAnnotation public String name; @SuppressWarnings("deprecation") @MethodAnnotation @RunTimeAnnotation @SourceAnnotation public void test()&#123; &#125;&#125; 测试类：AnnotationTest 12345678910111213141516171819202122232425262728293031323334public class AnnotationTest &#123; public static void main(String [] args)&#123; if ( Test.class.isAnnotationPresent(ClassAnnotation.class) ) &#123; ClassAnnotation testAnnotation = Test.class.getAnnotation(ClassAnnotation.class); //获取类的注解 System.out.println("获取类的注解 value:"+testAnnotation.value()); &#125; try &#123; Field field = Test.class.getDeclaredField("name"); field.setAccessible(true); if (field.isAnnotationPresent(FieldAnnotation.class)) &#123; FieldAnnotation fieldAnnotation = field.getAnnotation(FieldAnnotation.class); //获取类的注解 System.out.println("获取字段的注解 value:"+fieldAnnotation.value()); &#125; Method method = Test.class.getMethod("test"); if (method.isAnnotationPresent(MethodAnnotation.class)) &#123; MethodAnnotation methodAnnotation = method.getAnnotation(MethodAnnotation.class); //获取类的注解 System.out.println("获取方法的注解 value:"+methodAnnotation.value()); &#125; // 获取多个方法的注解 Annotation[] annotations = method.getAnnotations(); for( int i = 0;i &lt; annotations.length;i++) &#123; System.out.println("method annotation: "+annotations[i].annotationType().getSimpleName()); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125;catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125;miku &#125;&#125; 输出结果 12345获取类的注解 value:类注解获取字段的注解 value:字段注解获取方法的注解 value:方法注解method annotation: MethodAnnotationmethod annotation: RunTimeAnnotation 虽然给test()方法添加了四个注解,但SuppressWarnings和SourceAnnotation注解的 @Retention 都是 RetentionPolicy.RUNTIME,如果一个注解要在运行时被成功提取，那么 @Retention(RetentionPolicy.RUNTIME) 是必须的,所以只打印了两个注解. 如果注解难于理解，你就把它类同于标签，标签为了解释事物，注解为了解释代码。 注解的基本语法，创建如同接口，但是多了个 @ 符号。 注解的元注解。 注解的属性。 注解主要给编译器及工具类型的软件用的。 注解的提取需要借助于 Java 的反射技术，反射比较慢，所以注解使用时也需要谨慎计较时间成本。 学习链接： https://www.cnblogs.com/xdp-gacl/p/3622275.html https://blog.csdn.net/briblue/article/details/73824058]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
  </entry>
</search>
